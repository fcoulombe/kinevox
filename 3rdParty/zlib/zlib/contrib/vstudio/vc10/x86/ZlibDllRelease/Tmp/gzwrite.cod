; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\src\kinevox\3rdParty\zlib\zlib\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	_vsnprintf:PROC
EXTRN	_write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\src\kinevox\3rdparty\zlib\zlib\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_gz_init PROC						; COMDAT
; _state$ = esi

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);
; 20   : 
; 21   :     /* allocate input buffer */
; 22   :     state->in = malloc(state->want);

  00000	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	50		 push	 eax
  00006	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  00009	e8 00 00 00 00	 call	 _malloc
  0000e	8b d8		 mov	 ebx, eax
  00010	83 c4 04	 add	 esp, 4
  00013	89 5e 24	 mov	 DWORD PTR [esi+36], ebx

; 23   :     if (state->in == NULL) {

  00016	85 db		 test	 ebx, ebx
  00018	75 18		 jne	 SHORT $LN5@gz_init

; 24   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0001f	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 _gz_error
  00029	83 c4 04	 add	 esp, 4
  0002c	5f		 pop	 edi

; 25   :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	5b		 pop	 ebx

; 62   : }

  00031	c3		 ret	 0
$LN5@gz_init:

; 26   :     }
; 27   : 
; 28   :     /* only need output buffer and deflate state if compressing */
; 29   :     if (!state->direct) {

  00032	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00036	0f 85 89 00 00
	00		 jne	 $LN8@gz_init

; 30   :         /* allocate output buffer */
; 31   :         state->out = malloc(state->want);

  0003c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _malloc

; 32   :         if (state->out == NULL) {

  00045	33 c9		 xor	 ecx, ecx
  00047	83 c4 04	 add	 esp, 4
  0004a	89 46 28	 mov	 DWORD PTR [esi+40], eax
  0004d	3b c1		 cmp	 eax, ecx
  0004f	75 20		 jne	 SHORT $LN3@gz_init

; 33   :             free(state->in);

  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 _free

; 34   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0005c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00061	8b ce		 mov	 ecx, esi
  00063	e8 00 00 00 00	 call	 _gz_error
  00068	83 c4 08	 add	 esp, 8
  0006b	5f		 pop	 edi

; 35   :             return -1;

  0006c	83 c8 ff	 or	 eax, -1
  0006f	5b		 pop	 ebx

; 62   : }

  00070	c3		 ret	 0
$LN3@gz_init:

; 36   :         }
; 37   : 
; 38   :         /* allocate deflate memory, set up for gzip compression */
; 39   :         strm->zalloc = Z_NULL;
; 40   :         strm->zfree = Z_NULL;
; 41   :         strm->opaque = Z_NULL;
; 42   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 43   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  00071	6a 38		 push	 56			; 00000038H
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_05HBMOAMF@1?42?47?$AA@
  00078	89 4f 20	 mov	 DWORD PTR [edi+32], ecx
  0007b	89 4f 24	 mov	 DWORD PTR [edi+36], ecx
  0007e	89 4f 28	 mov	 DWORD PTR [edi+40], ecx
  00081	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00084	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00087	50		 push	 eax
  00088	6a 08		 push	 8
  0008a	6a 1f		 push	 31			; 0000001fH
  0008c	6a 08		 push	 8
  0008e	51		 push	 ecx
  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 _deflateInit2_@32

; 44   :         if (ret != Z_OK) {

  00095	85 c0		 test	 eax, eax
  00097	74 2c		 je	 SHORT $LN8@gz_init

; 45   :             free(state->out);

  00099	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _free

; 46   :             free(state->in);

  000a2	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _free

; 47   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000b0	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000b5	8b ce		 mov	 ecx, esi
  000b7	e8 00 00 00 00	 call	 _gz_error
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	5f		 pop	 edi

; 48   :             return -1;

  000c0	83 c8 ff	 or	 eax, -1
  000c3	5b		 pop	 ebx

; 62   : }

  000c4	c3		 ret	 0
$LN8@gz_init:

; 49   :         }
; 50   :     }
; 51   : 
; 52   :     /* mark state as initialized */
; 53   :     state->size = state->want;
; 54   : 
; 55   :     /* initialize write buffer if compressing */
; 56   :     if (!state->direct) {

  000c5	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  000c9	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000cc	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000cf	75 0c		 jne	 SHORT $LN1@gz_init

; 57   :         strm->avail_out = state->size;

  000d1	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 58   :         strm->next_out = state->out;

  000d4	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000d7	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 59   :         state->x.next = strm->next_out;

  000da	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@gz_init:

; 60   :     }
; 61   :     return 0;

  000dd	5f		 pop	 edi
  000de	33 c0		 xor	 eax, eax
  000e0	5b		 pop	 ebx

; 62   : }

  000e1	c3		 ret	 0
_gz_init ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_comp
_TEXT	SEGMENT
_flush$ = 8						; size = 4
_gz_comp PROC						; COMDAT
; _state$ = ebx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     int ret, got;
; 75   :     unsigned have;
; 76   :     z_streamp strm = &(state->strm);
; 77   : 
; 78   :     /* allocate memory if this is the first time through */
; 79   :     if (state->size == 0 && gz_init(state) == -1)

  00003	83 7b 1c 00	 cmp	 DWORD PTR [ebx+28], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d 7b 64	 lea	 edi, DWORD PTR [ebx+100]
  0000c	75 0c		 jne	 SHORT $LN21@gz_comp
  0000e	8b f3		 mov	 esi, ebx
  00010	e8 00 00 00 00	 call	 _gz_init
  00015	83 f8 ff	 cmp	 eax, -1

; 80   :         return -1;

  00018	74 4a		 je	 SHORT $LN24@gz_comp
$LN21@gz_comp:

; 81   : 
; 82   :     /* write directly if requested */
; 83   :     if (state->direct) {

  0001a	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  0001e	74 4b		 je	 SHORT $LN14@gz_comp

; 84   :         got = write(state->fd, strm->next_in, strm->avail_in);

  00020	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00023	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00025	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  00028	50		 push	 eax
  00029	51		 push	 ecx
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 _write
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 85   :         if (got < 0 || (unsigned)got != strm->avail_in) {

  00033	85 c0		 test	 eax, eax
  00035	78 12		 js	 SHORT $LN12@gz_comp
  00037	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  0003a	75 0d		 jne	 SHORT $LN12@gz_comp

; 88   :         }
; 89   :         strm->avail_in = 0;

  0003c	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00043	5f		 pop	 edi

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  00044	33 c0		 xor	 eax, eax
  00046	5e		 pop	 esi

; 130  : }

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN12@gz_comp:

; 86   :             gz_error(state, Z_ERRNO, zstrerror());

  00049	e8 00 00 00 00	 call	 __errno
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	50		 push	 eax
$LN25@gz_comp:
  00051	e8 00 00 00 00	 call	 _strerror
  00056	50		 push	 eax
  00057	83 c8 ff	 or	 eax, -1
  0005a	8b cb		 mov	 ecx, ebx
  0005c	e8 00 00 00 00	 call	 _gz_error
  00061	83 c4 08	 add	 esp, 8
$LN24@gz_comp:

; 87   :             return -1;

  00064	5f		 pop	 edi
  00065	83 c8 ff	 or	 eax, -1
  00068	5e		 pop	 esi

; 130  : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN14@gz_comp:

; 90   :         return 0;
; 91   :     }
; 92   : 
; 93   :     /* run deflate() on provided input until it produces no more output */
; 94   :     ret = Z_OK;

  0006b	33 c0		 xor	 eax, eax
  0006d	8d 49 00	 npad	 3
$LL11@gz_comp:

; 95   :     do {
; 96   :         /* write out current buffer contents if full, or if flushing, but if
; 97   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 98   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 99   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  00070	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00074	74 11		 je	 SHORT $LN6@gz_comp
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _flush$[ebp]
  00079	85 c9		 test	 ecx, ecx
  0007b	74 45		 je	 SHORT $LN8@gz_comp
  0007d	83 f9 04	 cmp	 ecx, 4
  00080	75 05		 jne	 SHORT $LN6@gz_comp
  00082	83 f8 01	 cmp	 eax, 1
  00085	75 3b		 jne	 SHORT $LN8@gz_comp
$LN6@gz_comp:

; 100  :             have = (unsigned)(strm->next_out - state->x.next);

  00087	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0008a	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0008d	2b f0		 sub	 esi, eax

; 101  :             if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
; 102  :                          (unsigned)got != have)) {

  0008f	74 16		 je	 SHORT $LN23@gz_comp
  00091	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00094	56		 push	 esi
  00095	50		 push	 eax
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _write
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	85 c0		 test	 eax, eax
  000a1	78 45		 js	 SHORT $LN4@gz_comp
  000a3	3b c6		 cmp	 eax, esi
  000a5	75 41		 jne	 SHORT $LN4@gz_comp
$LN23@gz_comp:

; 105  :             }
; 106  :             if (strm->avail_out == 0) {

  000a7	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  000ab	75 0c		 jne	 SHORT $LN3@gz_comp

; 107  :                 strm->avail_out = state->size;

  000ad	8b 53 1c	 mov	 edx, DWORD PTR [ebx+28]
  000b0	89 57 10	 mov	 DWORD PTR [edi+16], edx

; 108  :                 strm->next_out = state->out;

  000b3	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  000b6	89 47 0c	 mov	 DWORD PTR [edi+12], eax
$LN3@gz_comp:

; 109  :             }
; 110  :             state->x.next = strm->next_out;

  000b9	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000bc	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _flush$[ebp]
$LN8@gz_comp:

; 111  :         }
; 112  : 
; 113  :         /* compress */
; 114  :         have = strm->avail_out;

  000c2	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 115  :         ret = deflate(strm, flush);

  000c5	51		 push	 ecx
  000c6	57		 push	 edi
  000c7	e8 00 00 00 00	 call	 _deflate@8

; 116  :         if (ret == Z_STREAM_ERROR) {

  000cc	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  000cf	74 24		 je	 SHORT $LN20@gz_comp

; 119  :             return -1;
; 120  :         }
; 121  :         have -= strm->avail_out;

  000d1	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 122  :     } while (have);

  000d4	75 9a		 jne	 SHORT $LL11@gz_comp

; 123  : 
; 124  :     /* if that completed a deflate stream, allow another to start */
; 125  :     if (flush == Z_FINISH)

  000d6	83 7d 08 04	 cmp	 DWORD PTR _flush$[ebp], 4
  000da	75 06		 jne	 SHORT $LN1@gz_comp

; 126  :         deflateReset(strm);

  000dc	57		 push	 edi
  000dd	e8 00 00 00 00	 call	 _deflateReset@4
$LN1@gz_comp:

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  000e2	5f		 pop	 edi
  000e3	33 c0		 xor	 eax, eax
  000e5	5e		 pop	 esi

; 130  : }

  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN4@gz_comp:

; 103  :                 gz_error(state, Z_ERRNO, zstrerror());

  000e8	e8 00 00 00 00	 call	 __errno
  000ed	8b 10		 mov	 edx, DWORD PTR [eax]
  000ef	52		 push	 edx

; 104  :                 return -1;

  000f0	e9 5c ff ff ff	 jmp	 $LN25@gz_comp
$LN20@gz_comp:

; 117  :             gz_error(state, Z_STREAM_ERROR,
; 118  :                       "internal error: deflate stream corrupt");

  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  000fa	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000ff	8b cb		 mov	 ecx, ebx
  00101	e8 00 00 00 00	 call	 _gz_error
  00106	83 c4 04	 add	 esp, 4
  00109	5f		 pop	 edi
  0010a	83 c8 ff	 or	 eax, -1
  0010d	5e		 pop	 esi

; 130  : }

  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
_gz_comp ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_zero
_TEXT	SEGMENT
_first$ = -4						; size = 4
_len$ = 8						; size = 8
_gz_zero PROC						; COMDAT
; _state$ = eax

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d8		 mov	 ebx, eax

; 137  :     int first;
; 138  :     unsigned n;
; 139  :     z_streamp strm = &(state->strm);
; 140  : 
; 141  :     /* consume whatever's left in the input buffer */
; 142  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00007	83 7b 68 00	 cmp	 DWORD PTR [ebx+104], 0
  0000b	74 16		 je	 SHORT $LN5@gz_zero
  0000d	6a 00		 push	 0
  0000f	e8 00 00 00 00	 call	 _gz_comp
  00014	83 c4 04	 add	 esp, 4
  00017	83 f8 ff	 cmp	 eax, -1
  0001a	75 07		 jne	 SHORT $LN5@gz_zero

; 143  :         return -1;

  0001c	0b c0		 or	 eax, eax
  0001e	5b		 pop	 ebx

; 160  :     }
; 161  :     return 0;
; 162  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN5@gz_zero:
  00023	56		 push	 esi

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;
; 147  :     while (len) {

  00024	8b 75 08	 mov	 esi, DWORD PTR _len$[ebp]
  00027	8b c6		 mov	 eax, esi
  00029	0b 45 0c	 or	 eax, DWORD PTR _len$[ebp+4]
  0002c	57		 push	 edi
  0002d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
  00034	75 0d		 jne	 SHORT $LN4@gz_zero
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 160  :     }
; 161  :     return 0;
; 162  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
  0003d	8d 49 00	 npad	 3
$LL14@gz_zero:

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;
; 147  :     while (len) {

  00040	8b 75 08	 mov	 esi, DWORD PTR _len$[ebp]
$LN4@gz_zero:

; 148  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 149  :             (unsigned)len : state->size;

  00043	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00046	33 c0		 xor	 eax, eax
  00048	33 ff		 xor	 edi, edi
  0004a	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp+4]
  0004d	7f 08		 jg	 SHORT $LN8@gz_zero
  0004f	7c 04		 jl	 SHORT $LN13@gz_zero
  00051	3b ce		 cmp	 ecx, esi
  00053	77 02		 ja	 SHORT $LN8@gz_zero
$LN13@gz_zero:
  00055	8b f1		 mov	 esi, ecx
$LN8@gz_zero:

; 150  :         if (first) {

  00057	39 7d fc	 cmp	 DWORD PTR _first$[ebp], edi
  0005a	74 11		 je	 SHORT $LN2@gz_zero

; 151  :             memset(state->in, 0, n);

  0005c	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0005f	56		 push	 esi
  00060	57		 push	 edi
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  :             first = 0;

  0006a	89 7d fc	 mov	 DWORD PTR _first$[ebp], edi
$LN2@gz_zero:

; 153  :         }
; 154  :         strm->avail_in = n;

  0006d	89 73 68	 mov	 DWORD PTR [ebx+104], esi

; 155  :         strm->next_in = state->in;

  00070	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  00073	89 53 64	 mov	 DWORD PTR [ebx+100], edx

; 156  :         state->x.pos += n;

  00076	01 73 08	 add	 DWORD PTR [ebx+8], esi

; 157  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00079	57		 push	 edi
  0007a	11 7b 0c	 adc	 DWORD PTR [ebx+12], edi
  0007d	e8 00 00 00 00	 call	 _gz_comp
  00082	83 c4 04	 add	 esp, 4
  00085	83 f8 ff	 cmp	 eax, -1
  00088	74 1b		 je	 SHORT $LN11@gz_zero

; 159  :         len -= n;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _len$[ebp]
  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp+4]
  00090	2b c6		 sub	 eax, esi
  00092	1b cf		 sbb	 ecx, edi
  00094	89 45 08	 mov	 DWORD PTR _len$[ebp], eax
  00097	0b c1		 or	 eax, ecx
  00099	89 4d 0c	 mov	 DWORD PTR _len$[ebp+4], ecx
  0009c	75 a2		 jne	 SHORT $LL14@gz_zero
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx

; 160  :     }
; 161  :     return 0;
; 162  : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
$LN11@gz_zero:
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi

; 158  :             return -1;

  000a7	83 c8 ff	 or	 eax, -1
  000aa	5b		 pop	 ebx

; 160  :     }
; 161  :     return 0;
; 162  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_gz_zero ENDP
PUBLIC	_gzclose_w@4
; Function compile flags: /Ogtp
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 529  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 530  :     int ret = Z_OK;
; 531  :     gz_statep state;
; 532  : 
; 533  :     /* get internal structure */
; 534  :     if (file == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00007	56		 push	 esi
  00008	33 f6		 xor	 esi, esi
  0000a	85 db		 test	 ebx, ebx
  0000c	75 0b		 jne	 SHORT $LN8@gzclose_w
$LN11@gzclose_w:
  0000e	5e		 pop	 esi

; 535  :         return Z_STREAM_ERROR;

  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00014	5b		 pop	 ebx

; 565  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN8@gzclose_w:

; 536  :     state = (gz_statep)file;
; 537  : 
; 538  :     /* check that we're writing */
; 539  :     if (state->mode != GZ_WRITE)

  00019	81 7b 10 b1 79
	00 00		 cmp	 DWORD PTR [ebx+16], 31153 ; 000079b1H

; 540  :         return Z_STREAM_ERROR;

  00020	75 ec		 jne	 SHORT $LN11@gzclose_w

; 541  : 
; 542  :     /* check for seek request */
; 543  :     if (state->seek) {

  00022	39 73 58	 cmp	 DWORD PTR [ebx+88], esi
  00025	74 1d		 je	 SHORT $LN5@gzclose_w

; 544  :         state->seek = 0;
; 545  :         if (gz_zero(state, state->skip) == -1)

  00027	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  0002a	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	8b c3		 mov	 eax, ebx
  00031	89 73 58	 mov	 DWORD PTR [ebx+88], esi
  00034	e8 00 00 00 00	 call	 _gz_zero
  00039	83 c4 08	 add	 esp, 8
  0003c	83 f8 ff	 cmp	 eax, -1
  0003f	75 03		 jne	 SHORT $LN5@gzclose_w

; 546  :             ret = state->err;

  00041	8b 73 5c	 mov	 esi, DWORD PTR [ebx+92]
$LN5@gzclose_w:

; 547  :     }
; 548  : 
; 549  :     /* flush, free memory, and close file */
; 550  :     if (state->size) {

  00044	83 7b 1c 00	 cmp	 DWORD PTR [ebx+28], 0
  00048	74 39		 je	 SHORT $LN4@gzclose_w

; 551  :         if (gz_comp(state, Z_FINISH) == -1)

  0004a	6a 04		 push	 4
  0004c	e8 00 00 00 00	 call	 _gz_comp
  00051	83 c4 04	 add	 esp, 4
  00054	83 f8 ff	 cmp	 eax, -1
  00057	75 03		 jne	 SHORT $LN3@gzclose_w

; 552  :             ret = state->err;

  00059	8b 73 5c	 mov	 esi, DWORD PTR [ebx+92]
$LN3@gzclose_w:

; 553  :         if (!state->direct) {

  0005c	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  00060	75 15		 jne	 SHORT $LN2@gzclose_w

; 554  :             (void)deflateEnd(&(state->strm));

  00062	8d 53 64	 lea	 edx, DWORD PTR [ebx+100]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _deflateEnd@4

; 555  :             free(state->out);

  0006b	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _free
  00074	83 c4 04	 add	 esp, 4
$LN2@gzclose_w:

; 556  :         }
; 557  :         free(state->in);

  00077	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN4@gzclose_w:

; 558  :     }
; 559  :     gz_error(state, Z_OK, NULL);

  00083	6a 00		 push	 0
  00085	33 c0		 xor	 eax, eax
  00087	8b cb		 mov	 ecx, ebx
  00089	e8 00 00 00 00	 call	 _gz_error

; 560  :     free(state->path);

  0008e	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 _free

; 561  :     if (close(state->fd) == -1)

  00097	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _close
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	83 f8 ff	 cmp	 eax, -1
  000a6	75 02		 jne	 SHORT $LN1@gzclose_w

; 562  :         ret = Z_ERRNO;

  000a8	0b f0		 or	 esi, eax
$LN1@gzclose_w:

; 563  :     free(state);

  000aa	53		 push	 ebx
  000ab	e8 00 00 00 00	 call	 _free
  000b0	83 c4 04	 add	 esp, 4

; 564  :     return ret;

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 565  : }

  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams@12
; Function compile flags: /Ogtp
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 490  :     gz_statep state;
; 491  :     z_streamp strm;
; 492  : 
; 493  :     /* get internal structure */
; 494  :     if (file == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 0a		 jne	 SHORT $LN8@gzsetparam
$LN6@gzsetparam:

; 495  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5b		 pop	 ebx

; 524  : }

  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
$LN8@gzsetparam:

; 496  :     state = (gz_statep)file;
; 497  :     strm = &(state->strm);
; 498  : 
; 499  :     /* check that we're writing and that there's no error */
; 500  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00015	81 7b 10 b1 79
	00 00		 cmp	 DWORD PTR [ebx+16], 31153 ; 000079b1H
  0001c	75 ed		 jne	 SHORT $LN6@gzsetparam
  0001e	83 7b 5c 00	 cmp	 DWORD PTR [ebx+92], 0
  00022	75 e7		 jne	 SHORT $LN6@gzsetparam

; 501  :         return Z_STREAM_ERROR;
; 502  : 
; 503  :     /* if no change is requested, then do nothing */
; 504  :     if (level == state->level && strategy == state->strategy)

  00024	56		 push	 esi
  00025	8b 75 0c	 mov	 esi, DWORD PTR _level$[ebp]
  00028	57		 push	 edi
  00029	8b 7d 10	 mov	 edi, DWORD PTR _strategy$[ebp]
  0002c	3b 73 48	 cmp	 esi, DWORD PTR [ebx+72]
  0002f	75 05		 jne	 SHORT $LN5@gzsetparam
  00031	3b 7b 4c	 cmp	 edi, DWORD PTR [ebx+76]

; 505  :         return Z_OK;

  00034	74 63		 je	 SHORT $LN14@gzsetparam
$LN5@gzsetparam:

; 506  : 
; 507  :     /* check for seek request */
; 508  :     if (state->seek) {

  00036	83 7b 58 00	 cmp	 DWORD PTR [ebx+88], 0
  0003a	74 27		 je	 SHORT $LN11@gzsetparam

; 509  :         state->seek = 0;
; 510  :         if (gz_zero(state, state->skip) == -1)

  0003c	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  0003f	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00042	50		 push	 eax
  00043	51		 push	 ecx
  00044	8b c3		 mov	 eax, ebx
  00046	c7 43 58 00 00
	00 00		 mov	 DWORD PTR [ebx+88], 0
  0004d	e8 00 00 00 00	 call	 _gz_zero
  00052	83 c4 08	 add	 esp, 8
  00055	83 f8 ff	 cmp	 eax, -1
  00058	75 09		 jne	 SHORT $LN11@gzsetparam

; 511  :             return -1;

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	0b c0		 or	 eax, eax
  0005e	5b		 pop	 ebx

; 524  : }

  0005f	5d		 pop	 ebp
  00060	c2 0c 00	 ret	 12			; 0000000cH
$LN11@gzsetparam:

; 512  :     }
; 513  : 
; 514  :     /* change compression parameters for subsequent input */
; 515  :     if (state->size) {

  00063	83 7b 1c 00	 cmp	 DWORD PTR [ebx+28], 0
  00067	74 2a		 je	 SHORT $LN2@gzsetparam

; 516  :         /* flush previous input with previous parameters before changing */
; 517  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00069	83 7b 68 00	 cmp	 DWORD PTR [ebx+104], 0
  0006d	74 19		 je	 SHORT $LN1@gzsetparam
  0006f	6a 01		 push	 1
  00071	e8 00 00 00 00	 call	 _gz_comp
  00076	83 c4 04	 add	 esp, 4
  00079	83 f8 ff	 cmp	 eax, -1
  0007c	75 0a		 jne	 SHORT $LN1@gzsetparam

; 518  :             return state->err;

  0007e	8b 43 5c	 mov	 eax, DWORD PTR [ebx+92]
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 524  : }

  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
$LN1@gzsetparam:

; 519  :         deflateParams(strm, level, strategy);

  00088	57		 push	 edi
  00089	56		 push	 esi
  0008a	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _deflateParams@12
$LN2@gzsetparam:

; 520  :     }
; 521  :     state->level = level;

  00093	89 73 48	 mov	 DWORD PTR [ebx+72], esi

; 522  :     state->strategy = strategy;

  00096	89 7b 4c	 mov	 DWORD PTR [ebx+76], edi
$LN14@gzsetparam:

; 523  :     return Z_OK;

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	33 c0		 xor	 eax, eax
  0009d	5b		 pop	 ebx

; 524  : }

  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
PUBLIC	_gzflush@8
; Function compile flags: /Ogtp
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 457  :     gz_statep state;
; 458  : 
; 459  :     /* get internal structure */
; 460  :     if (file == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 08		 jne	 SHORT $LN7@gzflush

; 461  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5b		 pop	 ebx

; 482  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
$LN7@gzflush:

; 462  :     state = (gz_statep)file;
; 463  : 
; 464  :     /* check that we're writing and that there's no error */
; 465  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 7b 10 b1 79
	00 00		 cmp	 DWORD PTR [ebx+16], 31153 ; 000079b1H
  0001a	75 58		 jne	 SHORT $LN5@gzflush
  0001c	83 7b 5c 00	 cmp	 DWORD PTR [ebx+92], 0
  00020	75 52		 jne	 SHORT $LN5@gzflush

; 467  : 
; 468  :     /* check flush parameter */
; 469  :     if (flush < 0 || flush > Z_FINISH)

  00022	56		 push	 esi
  00023	8b 75 0c	 mov	 esi, DWORD PTR _flush$[ebp]
  00026	83 fe 04	 cmp	 esi, 4
  00029	77 3e		 ja	 SHORT $LN3@gzflush

; 471  : 
; 472  :     /* check for seek request */
; 473  :     if (state->seek) {

  0002b	83 7b 58 00	 cmp	 DWORD PTR [ebx+88], 0
  0002f	74 26		 je	 SHORT $LN1@gzflush

; 474  :         state->seek = 0;
; 475  :         if (gz_zero(state, state->skip) == -1)

  00031	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00034	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	8b c3		 mov	 eax, ebx
  0003b	c7 43 58 00 00
	00 00		 mov	 DWORD PTR [ebx+88], 0
  00042	e8 00 00 00 00	 call	 _gz_zero
  00047	83 c4 08	 add	 esp, 8
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	75 08		 jne	 SHORT $LN1@gzflush

; 476  :             return -1;

  0004f	5e		 pop	 esi
  00050	0b c0		 or	 eax, eax
  00052	5b		 pop	 ebx

; 482  : }

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
$LN1@gzflush:

; 477  :     }
; 478  : 
; 479  :     /* compress remaining data with requested flush */
; 480  :     gz_comp(state, flush);

  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 _gz_comp

; 481  :     return state->err;

  0005d	8b 43 5c	 mov	 eax, DWORD PTR [ebx+92]
  00060	83 c4 04	 add	 esp, 4
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx

; 482  : }

  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
$LN3@gzflush:
  00069	5e		 pop	 esi

; 470  :         return Z_STREAM_ERROR;

  0006a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006f	5b		 pop	 ebx

; 482  : }

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
$LN5@gzflush:

; 466  :         return Z_STREAM_ERROR;

  00074	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00079	5b		 pop	 ebx

; 482  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	_gzprintf
; Function compile flags: /Ogtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 305  :     int size, len;
; 306  :     gz_statep state;
; 307  :     z_streamp strm;
; 308  :     va_list va;
; 309  : 
; 310  :     /* get internal structure */
; 311  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN9@gzprintf

; 312  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 369  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN9@gzprintf:

; 313  :     state = (gz_statep)file;
; 314  :     strm = &(state->strm);
; 315  : 
; 316  :     /* check that we're writing and that there's no error */
; 317  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  00018	75 16		 jne	 SHORT $LN14@gzprintf
  0001a	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  0001e	75 10		 jne	 SHORT $LN14@gzprintf

; 318  :         return 0;
; 319  : 
; 320  :     /* make sure we have some buffer space */
; 321  :     if (state->size == 0 && gz_init(state) == -1)

  00020	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00024	75 0f		 jne	 SHORT $LN6@gzprintf
  00026	e8 00 00 00 00	 call	 _gz_init
  0002b	83 f8 ff	 cmp	 eax, -1
  0002e	75 05		 jne	 SHORT $LN6@gzprintf
$LN14@gzprintf:

; 322  :         return 0;

  00030	33 c0		 xor	 eax, eax
  00032	5e		 pop	 esi

; 369  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN6@gzprintf:

; 323  : 
; 324  :     /* check for seek request */
; 325  :     if (state->seek) {

  00035	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00039	74 1e		 je	 SHORT $LN4@gzprintf

; 326  :         state->seek = 0;
; 327  :         if (gz_zero(state, state->skip) == -1)

  0003b	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0003e	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	8b c6		 mov	 eax, esi
  00045	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0004c	e8 00 00 00 00	 call	 _gz_zero
  00051	83 c4 08	 add	 esp, 8
  00054	83 f8 ff	 cmp	 eax, -1

; 328  :             return 0;

  00057	74 d7		 je	 SHORT $LN14@gzprintf
$LN4@gzprintf:

; 329  :     }
; 330  : 
; 331  :     /* consume whatever's left in the input buffer */
; 332  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00059	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  0005d	74 13		 je	 SHORT $LN12@gzprintf
  0005f	53		 push	 ebx
  00060	6a 00		 push	 0
  00062	8b de		 mov	 ebx, esi
  00064	e8 00 00 00 00	 call	 _gz_comp
  00069	83 c4 04	 add	 esp, 4
  0006c	5b		 pop	 ebx
  0006d	83 f8 ff	 cmp	 eax, -1

; 333  :         return 0;

  00070	74 be		 je	 SHORT $LN14@gzprintf
$LN12@gzprintf:

; 334  : 
; 335  :     /* do the printf() into the input buffer, put length in len */
; 336  :     size = (int)(state->size);
; 337  :     state->in[size - 1] = 0;

  00072	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00075	57		 push	 edi
  00076	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  00079	c6 44 17 ff 00	 mov	 BYTE PTR [edi+edx-1], 0

; 338  :     va_start(va, format);
; 339  : #ifdef NO_vsnprintf
; 340  : #  ifdef HAS_vsprintf_void
; 341  :     (void)vsprintf((char *)(state->in), format, va);
; 342  :     va_end(va);
; 343  :     for (len = 0; len < size; len++)
; 344  :         if (state->in[len] == 0) break;
; 345  : #  else
; 346  :     len = vsprintf((char *)(state->in), format, va);
; 347  :     va_end(va);
; 348  : #  endif
; 349  : #else
; 350  : #  ifdef HAS_vsnprintf_void
; 351  :     (void)vsnprintf((char *)(state->in), size, format, va);
; 352  :     va_end(va);
; 353  :     len = strlen((char *)(state->in));
; 354  : #  else
; 355  :     len = vsnprintf((char *)(state->in), size, format, va);

  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR _format$[ebp]
  00081	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00084	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  00087	50		 push	 eax
  00088	51		 push	 ecx
  00089	57		 push	 edi
  0008a	52		 push	 edx
  0008b	e8 00 00 00 00	 call	 _vsnprintf
  00090	8b c8		 mov	 ecx, eax
  00092	83 c4 10	 add	 esp, 16			; 00000010H

; 356  :     va_end(va);
; 357  : #  endif
; 358  : #endif
; 359  : 
; 360  :     /* check that printf() results fit in buffer */
; 361  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  00095	85 c9		 test	 ecx, ecx
  00097	7e 26		 jle	 SHORT $LN1@gzprintf
  00099	3b cf		 cmp	 ecx, edi
  0009b	7d 22		 jge	 SHORT $LN1@gzprintf
  0009d	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000a0	80 7c 07 ff 00	 cmp	 BYTE PTR [edi+eax-1], 0
  000a5	75 18		 jne	 SHORT $LN1@gzprintf

; 363  : 
; 364  :     /* update buffer and position, defer compression until needed */
; 365  :     strm->avail_in = (unsigned)len;

  000a7	89 4e 68	 mov	 DWORD PTR [esi+104], ecx

; 366  :     strm->next_in = state->in;

  000aa	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  000ad	89 56 64	 mov	 DWORD PTR [esi+100], edx

; 367  :     state->x.pos += len;

  000b0	8b c1		 mov	 eax, ecx
  000b2	99		 cdq
  000b3	01 46 08	 add	 DWORD PTR [esi+8], eax
  000b6	5f		 pop	 edi

; 368  :     return len;

  000b7	8b c1		 mov	 eax, ecx
  000b9	11 56 0c	 adc	 DWORD PTR [esi+12], edx
  000bc	5e		 pop	 esi

; 369  : }

  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN1@gzprintf:
  000bf	5f		 pop	 edi

; 362  :         return 0;

  000c0	33 c0		 xor	 eax, eax
  000c2	5e		 pop	 esi

; 369  : }

  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzwrite@12
; Function compile flags: /Ogtp
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_put$ = 16						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 170  :     unsigned put = len;
; 171  :     unsigned n;
; 172  :     gz_statep state;
; 173  :     z_streamp strm;
; 174  : 
; 175  :     /* get internal structure */
; 176  :     if (file == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR _len$[ebp]
  0000b	89 7d 10	 mov	 DWORD PTR _put$[ebp], edi
  0000e	85 db		 test	 ebx, ebx

; 177  :         return 0;

  00010	74 27		 je	 SHORT $LN32@gzwrite

; 178  :     state = (gz_statep)file;
; 179  :     strm = &(state->strm);
; 180  : 
; 181  :     /* check that we're writing and that there's no error */
; 182  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00012	81 7b 10 b1 79
	00 00		 cmp	 DWORD PTR [ebx+16], 31153 ; 000079b1H
  00019	75 1e		 jne	 SHORT $LN32@gzwrite
  0001b	83 7b 5c 00	 cmp	 DWORD PTR [ebx+92], 0
  0001f	75 18		 jne	 SHORT $LN32@gzwrite

; 183  :         return 0;
; 184  : 
; 185  :     /* since an int is returned, make sure len fits in one, otherwise return
; 186  :        with an error (this avoids the flaw in the interface) */
; 187  :     if ((int)len < 0) {

  00021	85 ff		 test	 edi, edi
  00023	79 1c		 jns	 SHORT $LN30@gzwrite

; 188  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0002a	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0002f	8b cb		 mov	 ecx, ebx
  00031	e8 00 00 00 00	 call	 _gz_error
  00036	83 c4 04	 add	 esp, 4
$LN32@gzwrite:

; 189  :         return 0;

  00039	5f		 pop	 edi
  0003a	33 c0		 xor	 eax, eax
  0003c	5b		 pop	 ebx

; 240  : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN30@gzwrite:

; 190  :     }
; 191  : 
; 192  :     /* if len is zero, avoid unnecessary operations */
; 193  :     if (len == 0)
; 194  :         return 0;

  00041	74 f6		 je	 SHORT $LN32@gzwrite

; 195  : 
; 196  :     /* allocate memory if this is the first time through */
; 197  :     if (state->size == 0 && gz_init(state) == -1)

  00043	83 7b 1c 00	 cmp	 DWORD PTR [ebx+28], 0
  00047	56		 push	 esi
  00048	75 0c		 jne	 SHORT $LN24@gzwrite
  0004a	8b f3		 mov	 esi, ebx
  0004c	e8 00 00 00 00	 call	 _gz_init
  00051	83 f8 ff	 cmp	 eax, -1

; 198  :         return 0;

  00054	74 75		 je	 SHORT $LN31@gzwrite
$LN24@gzwrite:

; 199  : 
; 200  :     /* check for seek request */
; 201  :     if (state->seek) {

  00056	33 f6		 xor	 esi, esi
  00058	39 73 58	 cmp	 DWORD PTR [ebx+88], esi
  0005b	74 1a		 je	 SHORT $LN28@gzwrite

; 202  :         state->seek = 0;
; 203  :         if (gz_zero(state, state->skip) == -1)

  0005d	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00060	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00063	50		 push	 eax
  00064	51		 push	 ecx
  00065	8b c3		 mov	 eax, ebx
  00067	89 73 58	 mov	 DWORD PTR [ebx+88], esi
  0006a	e8 00 00 00 00	 call	 _gz_zero
  0006f	83 c4 08	 add	 esp, 8
  00072	83 f8 ff	 cmp	 eax, -1

; 204  :             return 0;

  00075	74 54		 je	 SHORT $LN31@gzwrite
$LN28@gzwrite:

; 205  :     }
; 206  : 
; 207  :     /* for small len, copy to input buffer, otherwise compress directly */
; 208  :     if (len < state->size) {

  00077	3b 7b 1c	 cmp	 edi, DWORD PTR [ebx+28]
  0007a	73 58		 jae	 SHORT $LN10@gzwrite
  0007c	8d 64 24 00	 npad	 4
$LL9@gzwrite:

; 209  :         /* copy to input buffer, compress when full */
; 210  :         do {
; 211  :             if (strm->avail_in == 0)

  00080	8b 43 68	 mov	 eax, DWORD PTR [ebx+104]
  00083	85 c0		 test	 eax, eax
  00085	75 06		 jne	 SHORT $LN6@gzwrite

; 212  :                 strm->next_in = state->in;

  00087	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  0008a	89 53 64	 mov	 DWORD PTR [ebx+100], edx
$LN6@gzwrite:

; 213  :             n = state->size - strm->avail_in;

  0008d	8b 73 1c	 mov	 esi, DWORD PTR [ebx+28]
  00090	2b f0		 sub	 esi, eax

; 214  :             if (n > len)

  00092	3b f7		 cmp	 esi, edi
  00094	76 02		 jbe	 SHORT $LN5@gzwrite

; 215  :                 n = len;

  00096	8b f7		 mov	 esi, edi
$LN5@gzwrite:

; 216  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0009b	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  0009e	56		 push	 esi
  0009f	51		 push	 ecx
  000a0	03 d0		 add	 edx, eax
  000a2	52		 push	 edx
  000a3	e8 00 00 00 00	 call	 _memcpy

; 217  :             strm->avail_in += n;

  000a8	01 73 68	 add	 DWORD PTR [ebx+104], esi
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  :             state->x.pos += n;

  000ae	01 73 08	 add	 DWORD PTR [ebx+8], esi
  000b1	83 53 0c 00	 adc	 DWORD PTR [ebx+12], 0

; 219  :             buf = (char *)buf + n;

  000b5	01 75 0c	 add	 DWORD PTR _buf$[ebp], esi

; 220  :             len -= n;

  000b8	2b fe		 sub	 edi, esi

; 221  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000ba	74 48		 je	 SHORT $LN27@gzwrite
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 _gz_comp
  000c3	83 c4 04	 add	 esp, 4
  000c6	83 f8 ff	 cmp	 eax, -1
  000c9	75 b5		 jne	 SHORT $LL9@gzwrite
$LN31@gzwrite:
  000cb	5e		 pop	 esi
  000cc	5f		 pop	 edi

; 222  :                 return 0;

  000cd	33 c0		 xor	 eax, eax
  000cf	5b		 pop	 ebx

; 240  : }

  000d0	5d		 pop	 ebp
  000d1	c2 0c 00	 ret	 12			; 0000000cH
$LN10@gzwrite:

; 223  :         } while (len);
; 224  :     }
; 225  :     else {
; 226  :         /* consume whatever's left in the input buffer */
; 227  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000d4	39 73 68	 cmp	 DWORD PTR [ebx+104], esi
  000d7	74 0e		 je	 SHORT $LN2@gzwrite
  000d9	56		 push	 esi
  000da	e8 00 00 00 00	 call	 _gz_comp
  000df	83 c4 04	 add	 esp, 4
  000e2	83 f8 ff	 cmp	 eax, -1

; 228  :             return 0;

  000e5	74 e4		 je	 SHORT $LN31@gzwrite
$LN2@gzwrite:

; 229  : 
; 230  :         /* directly compress user buffer to file */
; 231  :         strm->avail_in = len;
; 232  :         strm->next_in = (voidp)buf;

  000e7	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  000ea	89 7b 68	 mov	 DWORD PTR [ebx+104], edi
  000ed	89 43 64	 mov	 DWORD PTR [ebx+100], eax

; 233  :         state->x.pos += len;

  000f0	01 7b 08	 add	 DWORD PTR [ebx+8], edi

; 234  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000f3	56		 push	 esi
  000f4	11 73 0c	 adc	 DWORD PTR [ebx+12], esi
  000f7	e8 00 00 00 00	 call	 _gz_comp
  000fc	83 c4 04	 add	 esp, 4
  000ff	83 f8 ff	 cmp	 eax, -1

; 235  :             return 0;

  00102	74 c7		 je	 SHORT $LN31@gzwrite
$LN27@gzwrite:

; 236  :     }
; 237  : 
; 238  :     /* input was all buffered or compressed (put will fit in int) */
; 239  :     return (int)put;

  00104	8b 45 10	 mov	 eax, DWORD PTR _put$[ebp]
  00107	5e		 pop	 esi
  00108	5f		 pop	 edi
  00109	5b		 pop	 ebx

; 240  : }

  0010a	5d		 pop	 ebp
  0010b	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
PUBLIC	_gzputs@8
; Function compile flags: /Ogtp
;	COMDAT _gzputs@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  :     int ret;
; 291  :     unsigned len;
; 292  : 
; 293  :     /* write string */
; 294  :     len = (unsigned)strlen(str);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$LL5@gzputs:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL5@gzputs
  00017	2b c6		 sub	 eax, esi
  00019	8b f0		 mov	 esi, eax

; 295  :     ret = gzwrite(file, str, len);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0001e	56		 push	 esi
  0001f	52		 push	 edx
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _gzwrite@12

; 296  :     return ret == 0 && len != 0 ? -1 : ret;

  00026	85 c0		 test	 eax, eax
  00028	75 07		 jne	 SHORT $LN4@gzputs
  0002a	85 f6		 test	 esi, esi
  0002c	74 03		 je	 SHORT $LN4@gzputs
  0002e	83 c8 ff	 or	 eax, -1
$LN4@gzputs:
  00031	5e		 pop	 esi

; 297  : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputc@8
; Function compile flags: /Ogtp
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 247  :     unsigned char buf[1];
; 248  :     gz_statep state;
; 249  :     z_streamp strm;
; 250  : 
; 251  :     /* get internal structure */
; 252  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 08		 jne	 SHORT $LN8@gzputc
$LN12@gzputc:

; 253  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 283  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
$LN8@gzputc:

; 254  :     state = (gz_statep)file;
; 255  :     strm = &(state->strm);
; 256  : 
; 257  :     /* check that we're writing and that there's no error */
; 258  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001a	75 ef		 jne	 SHORT $LN12@gzputc
  0001c	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00020	75 e9		 jne	 SHORT $LN12@gzputc

; 259  :         return -1;
; 260  : 
; 261  :     /* check for seek request */
; 262  :     if (state->seek) {

  00022	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00026	74 1e		 je	 SHORT $LN4@gzputc

; 263  :         state->seek = 0;
; 264  :         if (gz_zero(state, state->skip) == -1)

  00028	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0002b	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	8b c6		 mov	 eax, esi
  00032	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00039	e8 00 00 00 00	 call	 _gz_zero
  0003e	83 c4 08	 add	 esp, 8
  00041	83 f8 ff	 cmp	 eax, -1

; 265  :             return -1;

  00044	74 c5		 je	 SHORT $LN12@gzputc
$LN4@gzputc:

; 266  :     }
; 267  : 
; 268  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 269  :        initialized) */
; 270  :     if (strm->avail_in < state->size) {

  00046	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  00049	3b 4e 1c	 cmp	 ecx, DWORD PTR [esi+28]
  0004c	73 2c		 jae	 SHORT $LN3@gzputc

; 271  :         if (strm->avail_in == 0)

  0004e	85 c9		 test	 ecx, ecx
  00050	75 06		 jne	 SHORT $LN2@gzputc

; 272  :             strm->next_in = state->in;

  00052	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00055	89 56 64	 mov	 DWORD PTR [esi+100], edx
$LN2@gzputc:

; 273  :         strm->next_in[strm->avail_in++] = c;

  00058	8b 56 64	 mov	 edx, DWORD PTR [esi+100]
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0005e	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	01 4e 68	 add	 DWORD PTR [esi+104], ecx

; 274  :         state->x.pos++;

  00069	01 4e 08	 add	 DWORD PTR [esi+8], ecx
  0006c	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 275  :         return c & 0xff;

  00070	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00075	5e		 pop	 esi

; 283  : }

  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN3@gzputc:
  0007a	53		 push	 ebx

; 276  :     }
; 277  : 
; 278  :     /* no room in buffer or not initialized, use gz_write() */
; 279  :     buf[0] = c;

  0007b	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]

; 280  :     if (gzwrite(file, buf, 1) != 1)

  0007e	6a 01		 push	 1
  00080	8d 45 0b	 lea	 eax, DWORD PTR _buf$[ebp]
  00083	50		 push	 eax
  00084	56		 push	 esi
  00085	88 5d 0b	 mov	 BYTE PTR _buf$[ebp], bl
  00088	e8 00 00 00 00	 call	 _gzwrite@12
  0008d	83 f8 01	 cmp	 eax, 1
  00090	74 09		 je	 SHORT $LN1@gzputc

; 281  :         return -1;

  00092	5b		 pop	 ebx
  00093	83 c8 ff	 or	 eax, -1
  00096	5e		 pop	 esi

; 283  : }

  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
$LN1@gzputc:

; 282  :     return c & 0xff;

  0009b	8b c3		 mov	 eax, ebx
  0009d	5b		 pop	 ebx
  0009e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a3	5e		 pop	 esi

; 283  : }

  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
_gzputc@8 ENDP
END
